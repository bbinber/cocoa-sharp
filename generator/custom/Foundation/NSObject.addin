//
//  NSObject.cs
//
//  Authors
//    - C.J. Collier, Collier Technologies, <cjcollier@colliertech.org>
//    - Urs C. Muff, Quark Inc., <umuff@quark.com>
//    - Kangaroo, Geoff Norton
//    - Adham Findlay
//
//  Copyright (c) 2004 Quark Inc. and Collier Technologies.  All rights reserved.
//
//	$Header: /home/miguel/third-conversion/public/cocoa-sharp/generator/custom/Foundation/NSObject.addin,v 1.29 2004/09/07 21:16:37 adhamh Exp $
//

		public static object NS2Net(IntPtr raw) {
			return TypeConverter.NS2Net(raw);
		}
		
		public static IntPtr Net2NS(object obj) {
			return TypeConverter.Net2NS(obj);
		}
	
        public static string debugLevel = System.Environment.GetEnvironmentVariable("COCOASHARP_DEBUG_LEVEL");

		public static void DebugLog(int debug_level, string message, params object[]args) {
			//level 1 = error
			//level 2 = debug
			if (debugLevel != null  && Int32.Parse(debugLevel) >= debug_level) {
				Console.WriteLine(message,args);
				}
		}

		private IntPtr _obj;
		private BridgeDelegate _delegate;
		protected bool _release;
		
		public static IDictionary Objects = new Hashtable();
		static IDictionary NSClasses = new Hashtable();

		#region -- Glue --
		[DllImport("/System/Library/Frameworks/Foundation.framework/Foundation")]
		protected internal static extern IntPtr /*Method*/ class_getInstanceMethod(IntPtr /*Class*/ aClass, IntPtr /*SEL*/ aSelector);

		[DllImport("Glue")]
		protected internal static extern IntPtr /*(NSMethodSignature *)*/ MakeMethodSignature(string types);

		[DllImport("Glue")]
		protected static extern IntPtr /*(Class)*/ CreateClassDefinition(string name, string superclassName, int nummethods, IntPtr[] methods, IntPtr[] signatures, int numivars, IntPtr[] ivarnames, IntPtr[] ivartypes, int[] ivarsizes);

		[DllImport("Glue")]
		protected static extern IntPtr /*(id)*/ DotNetForwarding_initWithManagedDelegate(IntPtr THIS, BridgeDelegate managedDelegate);

		[DllImport("Glue")]
		static extern void SetConstructorDelegate(ConstructorDelegate aDelegate, GetManagedDelegate aGetManagedDelegate);
		#endregion

		protected enum GlueDelegateWhat {
			methodSignatureForSelector = 0,
			forwardInvocation = 1,
		}

		protected delegate IntPtr BridgeDelegate(GlueDelegateWhat what,IntPtr /*(NSInvocation*)*/ invocation);

		protected static IntPtr /*(Class)*/ NSRegisterClass(Type type) {
			string name = type.Name;
			foreach (RegisterAttribute regAttr in Attribute.GetCustomAttributes(type,typeof(RegisterAttribute))) {
				if(regAttr.Name != null)
					name = regAttr.Name;

				break;
			}
NSObject.DebugLog(1, "DEBUG: NSRegisterClass {0} as {1}", type.Name, name);
			if (sConstructorDelegate == null) {
				sConstructorDelegate = new ConstructorDelegate(ConstructObject);
				sGetManagedDelegate = new GetManagedDelegate(GetDelegateForObject);
				SetConstructorDelegate(sConstructorDelegate,sGetManagedDelegate);
			}

			ObjCClassRepresentation r = BridgeHelper.GenerateObjCRepresentation(type);

			IntPtr[] methods = new IntPtr[r.NumMethods];
			IntPtr[] signatures = new IntPtr[r.NumMethods];

			for(int i = 0; i < r.NumMethods; i++) {
				methods[i] = Marshal.StringToCoTaskMemAnsi(r.Methods[i]);
				signatures[i] = Marshal.StringToCoTaskMemAnsi(r.Signatures[i]);
			}
			ObjCClassMemberRepresentation m = BridgeHelper.GenerateObjCMemberRepresentation(type);

			IntPtr[] memberNames = new IntPtr[m.NumMembers];
			IntPtr[] memberTypes = new IntPtr[m.NumMembers];

			for(int i = 0; i < m.NumMembers; i++) {
				memberNames[i] = Marshal.StringToCoTaskMemAnsi(m.Names[i]);
				memberTypes[i] = Marshal.StringToCoTaskMemAnsi(m.Types[i]);
			}
			IntPtr retval = IntPtr.Zero;
			retval = CreateClassDefinition(name, type.BaseType.Name, r.NumMethods, methods, signatures, m.NumMembers, memberNames, memberTypes, m.Sizes); 
			for(int i = 0; i < r.NumMethods; i++) {
				Marshal.FreeCoTaskMem(methods[i]);
				Marshal.FreeCoTaskMem(signatures[i]);
			}
			for(int i = 0; i < m.NumMembers; i++) {
				Marshal.FreeCoTaskMem(memberNames[i]);
				Marshal.FreeCoTaskMem(memberTypes[i]);
			}
			return retval;
		}

		protected IntPtr MethodInvoker(GlueDelegateWhat what,IntPtr arg) {
			switch (what) {
				case GlueDelegateWhat.methodSignatureForSelector:
					return MakeMethodSignature(BridgeHelper.GenerateMethodSignature(this.GetType(), NSString.FromSEL(arg).ToString()));
				case GlueDelegateWhat.forwardInvocation:
				{
					NSInvocation invocation = (NSInvocation)NS2Net(arg);
					object[] args = BridgeHelper.ProcessInvocation(this.GetType(),invocation);
					
					invocation.returnValue = BridgeHelper.InvokeMethodByObject(this, invocation.selector, args);
					break;
				}
			}
			return IntPtr.Zero;
		}

		~NSObject() {
			// this will leak memory, but we have to synchronize managed and objc runtime
#if RELEASE_MEM
			if (Raw != IntPtr.Zero && _release) {
NSObject.DebugLog(1, "DEBUG: ~{0}: ptr=0x{1,8:x}", this.GetType().Name, (int) Raw);
				release();
			}
#endif
			SetRaw(IntPtr.Zero,false);
		}

		public NSObject() {
			Type myType = this.GetType();
			IntPtr cls = IntPtr.Zero;
			if (!NSClasses.Contains(myType)) {
				cls = Apple.Foundation.Class.Get(myType.Name);
				if (cls == IntPtr.Zero)
					cls = NSRegisterClass(myType);
				
				NSClasses[myType] = cls;
				
				TypeConverter.Name2Type[myType.Name] = myType;
			}
			else
				cls = (IntPtr)NSClasses[myType];

			SetRaw(NSObject__alloc0(cls),true);
			if (class_getInstanceMethod(cls, NSString.NSSelector("initWithManagedDelegate:")) != IntPtr.Zero) {
				_delegate = new BridgeDelegate(this.MethodInvoker);
				SetRaw(DotNetForwarding_initWithManagedDelegate(Raw,_delegate),_release);
			}
		}

		protected internal NSObject(IntPtr raw,bool release) {
			SetRaw(raw,release);
		}

		public object _GetInstanceVar(string name,Type t)
		{
			return BridgeHelper.GetInstanceVar(Raw,name,t);
		}

		public void _SetInstanceVar(string name,object value)
		{
			BridgeHelper.SetInstanceVar(Raw,name,value);
		}
		
		public void _UpdateMembers(bool import)
		{
			BridgeHelper.UpdateMembers(this,import);
		}

		public IntPtr Raw {
			get { return _obj; }
		}

		public void SetRaw(IntPtr raw,bool release) {
			if (raw == _obj)
				return;

//NSObject.DebugLog(1, "DEBUG: Change Raw for {0}[{1}]: 0x{2,8:x} -> 0x{3,8:x}", this.GetType().Name, release, (int) _obj, (int) raw);
			if (_release && _obj != IntPtr.Zero)
				lock (Objects) {
NSObject.DebugLog(1, "DEBUG: Remove Raw for {0}: ptr=0x{1,8:x}", this.GetType().Name, (int) _obj);
					Objects.Remove(_obj);
				}

			_obj = raw;
			_release = release;

			if (_release && _obj != IntPtr.Zero)
				lock (Objects) {
NSObject.DebugLog(1, "DEBUG: Add Raw for {0}: ptr=0x{1,8:x}", this.GetType().Name, (int) _obj);
					Objects.Add(_obj, new WeakReference(this));
				}
		}

		public string ClassName {
			get { return Marshal.PtrToStringAnsi(TypeConverter.GetObjectClassName(Raw)); }
		}

		#region -- Constructor Delegate --
		delegate void ConstructorDelegate (IntPtr /*(id)*/ raw, string aClass);
#if JIT_HACK_FIXED
		delegate BridgeDelegate GetManagedDelegate (IntPtr /*(id)*/ raw);
#else
		delegate void GetManagedDelegate (IntPtr /*(id)*/ raw);
		[DllImport("Glue")]
		protected static extern void SetJIT_HACK_Delegate(BridgeDelegate managedDelegate);
#endif
		static ConstructorDelegate sConstructorDelegate;
		static GetManagedDelegate sGetManagedDelegate;
		static IDictionary NativeObjects = new Hashtable();

		static void ConstructObject(IntPtr /*(id)*/ raw, string className) {
NSObject.DebugLog(1, "DEBUG: ObjC asked us to make {0} for 0x{1,8:x}", className, (int)raw);

			Type myType = TypeConverter.NS2Type(className);
			IntPtr cls;
			if (!NSClasses.Contains(myType)) {
				cls = Apple.Foundation.Class.Get(myType.Name);
				if (cls == IntPtr.Zero)
					cls = NSRegisterClass(myType);

				NSClasses[myType] = cls;
			}
			else cls = (IntPtr)NSClasses[myType];

			NSObject managedObject = (NSObject)NS2Net(raw);
			managedObject.SetRaw(IntPtr.Zero,false);
			managedObject.SetRaw(raw,true);
			managedObject._delegate = new BridgeDelegate(managedObject.MethodInvoker);
			if (class_getInstanceMethod(cls, NSString.NSSelector("initWithManagedDelegate:")) != IntPtr.Zero)
				DotNetForwarding_initWithManagedDelegate(raw,managedObject._delegate);

			NativeObjects[raw] = managedObject;
		}

		static
#if JIT_HACK_FIXED
		BridgeDelegate
#else
		void
#endif
		GetDelegateForObject(IntPtr /*(id)*/ raw) {
NSObject.DebugLog(1, "DEBUG: ObjC us for the delegate 0x{0,8:x}", (int)raw);
			NSObject managedObject = (NSObject)NativeObjects[raw];
			if (managedObject != null)
#if JIT_HACK_FIXED
 				return managedObject._delegate;
#else
				SetJIT_HACK_Delegate(managedObject._delegate);
#endif
NSObject.DebugLog(1, "ERROR: native object was not registered 0x{0,8:x}", (int)raw);
#if JIT_HACK_FIXED
			return null;
#else
			return;
#endif
		}

		delegate int ClassHandlerDelegate(string className);
		[DllImport("libCocoaSharpGlue.dylib")]
		static extern void InitGlue(ClassHandlerDelegate del);
		static ClassHandlerDelegate sClassHandler;
	
		static int ClassHandler(string className) {
NSObject.DebugLog(1, "DEBUG: ClassHandler: " + className);
			Type t = TypeConverter.NS2Type(className);
			if (t != null) {
				NSRegisterClass(t);
				return 1;
			}
			return 0;
		}

		static NSObject() {
			sClassHandler = new ClassHandlerDelegate(ClassHandler);
			InitGlue(sClassHandler);
		}

		#endregion

//***************************************************************************
//
// $Log: NSObject.addin,v $
// Revision 1.29  2004/09/07 21:16:37  adhamh
// change ERROR messages to also call NSObject.DebugLog instead of Console.WriteLine.
//
// Revision 1.28  2004/09/07 21:08:57  adhamh
// Added code for disabling debug logging.
//
// if the env var COCOASHARP_DEBUG_LEVEL is not set then logging is off.
//
// COCOASHARP_DEBUG_LEVEL can be anything greater than 1 so that later we can add debugging levels if needed.
//
// Revision 1.27  2004/07/24 16:31:06  gnorton
// Renamed Attributes from ObjC*->* (more logical/less typing)
//
// Revision 1.26  2004/07/03 20:02:41  urs
// Some attribute love
//
// Revision 1.25  2004/07/03 03:48:44  gnorton
// ObjCRegisterAttribute support; we can now overload any ObjCClassname -> .NET Classname mapping
//
// Revision 1.24  2004/07/03 03:27:51  gnorton
// NIB lubbin
//
// Revision 1.23  2004/07/02 21:45:58  urs
// Initial POC for NIB binding, make test/nib work
//
// Revision 1.22  2004/07/02 17:15:27  gnorton
// NIB hack workaround fixed.
//
// Revision 1.21  2004/07/02 13:29:30  urs
// Cleanup build process again, and checkin bin's for monodoc (as temp solution)
//
// Revision 1.20  2004/07/02 12:45:10  urs
// cleanup
//
// Revision 1.19  2004/07/01 22:01:50  urs
// Remove static ctor, since it produces a JIT error
//
// Revision 1.18  2004/07/01 21:26:03  urs
// Support for NIB files: objects that are not constructed by us
//
// Revision 1.17  2004/07/01 20:18:45  gnorton
// Initial NIB callback loading support (incomplete)
//
// Revision 1.16  2004/07/01 20:09:57  urs
// Fix GC issues
//
// Revision 1.15  2004/07/01 16:01:41  urs
// Fix some GC issues, but mostly just do stuff more explicit
// Still not working with GC on
//
// Revision 1.14  2004/06/30 19:29:23  urs
// Cleanup
//
// Revision 1.13  2004/06/30 16:51:00  urs
// Making monodoc happy
//
// Revision 1.12  2004/06/29 20:32:05  urs
// More cleanup
//
// Revision 1.11  2004/06/29 18:28:46  gnorton
// Remove the ptr from the hashtable when we're DToring it.
// Remove some debugging WriteLines from NSO
//
// Revision 1.10  2004/06/29 18:11:07  gnorton
// Support dereferencing our WeakReference to return the real object; not make a new one
//
// Revision 1.9  2004/06/29 16:42:34  gnorton
// Much better signature generator
//
// Revision 1.8  2004/06/29 15:24:25  gnorton
// Better support for different argument type (PtrTrStructure/StructureToPtr/SizeOf usage)
//
// Revision 1.7  2004/06/29 13:35:52  urs
// make tree green again, I like green :)
//
// Revision 1.6  2004/06/28 19:18:31  urs
// Implement latest name bindings changes, and using objective-c reflection to see is a type is a OC class
//
// Revision 1.5  2004/06/27 20:41:45  gnorton
// Support for NSBrowser and int args/rets
//
// Revision 1.4  2004/06/26 06:52:32  urs
// Remove hardcoding in TypeConvertor, and autoregister new classes
//
// Revision 1.3  2004/06/24 20:02:35  urs
// Fix string issues
//
// Revision 1.2  2004/06/24 06:29:36  gnorton
// Make foundation compile.
//
// Revision 1.1  2004/06/24 03:47:30  urs
// initial custom stuff
//
// Revision 1.19  2004/06/23 17:55:46  urs
// Make test compile with the lasted glue API name change
//
// Revision 1.18  2004/06/20 02:07:25  urs
// Clean up, move Apple.Tools into Foundation since it will need it
// No need to allocate memory for getArgumentAtIndex of NSInvocation
//
// Revision 1.17  2004/06/19 20:42:59  gnorton
// Code cleanup (remove some old methods/clean some console.writelines)
// Modify NS2Net and NSObject destructor to be able to FreeCoTaskMem that we allocate in our argument parser.
//
// Revision 1.16  2004/06/19 17:19:27  gnorton
// Broken API fixes.
// Delegates and methods with multi-argument support working.
// Argument parsing and casting working for all our known classes.
//
// Revision 1.15  2004/06/18 20:13:00  gnorton
// Support for multi-argument method signatures/calling in .Net
//
// Revision 1.14  2004/06/18 03:42:45  gnorton
// Doesn't need to be unsafe anymore because we can pass IntPtr[] and have it become char ** nicely after our conversion; we still clean up the managed memory tho
//
// Revision 1.13  2004/06/17 16:10:45  gnorton
// Cleanup
//
// Revision 1.12  2004/06/17 15:58:07  urs
// Public API cleanup, making properties and using .Net types rather then NS*
//
// Revision 1.11  2004/06/17 13:06:27  urs
// - release cleanup: only call release when requested
// - loader cleanup
//
// Revision 1.10  2004/06/17 05:48:00  gnorton
// Modified to move non apple stuff out of NSObject
//
// Revision 1.9  2004/06/16 12:20:27  urs
// Add CVS headers comments, authors and Copyright info, feel free to add your name or change what is appropriate
//
//***************************************************************************
