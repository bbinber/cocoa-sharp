#!/usr/bin/perl -w

use strict;
use File::Basename;

#$| = 0;
my %protocols = ();

makeDirs();

# get protocols
print("Processing interfaces.\n");
parseDir("/System/Library/Frameworks/AppKit.framework/Headers", "appkit", 1);
parseDir("/System/Library/Frameworks/Foundation.framework/Headers", "foundation", 1);
print("Finished processing interfaces.\n");

# output interfaces
parseDir("/System/Library/Frameworks/AppKit.framework/Headers", "appkit", 0);
parseDir("/System/Library/Frameworks/Foundation.framework/Headers", "foundation", 0);

sub parseMethod {
    my $origmethod = shift();
    my $class = shift();
    my $methodHash = shift();
    my $objCHash = shift();
    my @return = ();

    chomp($origmethod);

    # TODO: only overwrite to a section delimited by:
    # /* GENERATED BY genstubs.pl     */
    # /* END GENRATION BY genstubs.pl */

#    print("$origmethod\n");

    # Check for unsupported methods and return commented function
    # Unsupported methods include:
    # <.*>
    if($origmethod =~ /<.*>/ or
       # varargs don't work.
       # Need another method of passing variable number of args (...)
       # until then, comment such methods as UNSUPPORTED
       $origmethod =~ /\.\.\./
      ) {
        $origmethod =~ s:/::g;
        return "/* UNSUPPORTED: \n$origmethod\n */\n\n";
    }

    # It seems that methods take one of two formats.  Zero arguments:
    # - (RETURNTYPE)MethodName;
    # or N arguments
    # - (RETURNTYPE)MethodName:(TYPE0)Arg0 ... ArgNName:(TYPEN)ArgN;

    $origmethod =~ /\s*([+-])\s*(?:\(([^\)]+)\))?(.+)/;

    my $methodType = $1;
    my $retType = ($2 ? $2 : "id");
    my $remainder = $3;

    my $isClassMethod = (defined($methodType) ? ($methodType eq "+") : 0);
    
    $retType =~ s/oneway //;

    # get rid of comments
    $remainder =~ s://.*::;
    $remainder =~ s:/\*.*\*/::;
    
    # These arrays store our method names, their arg names and types
    my(@methodName, @name, @type);

    my $message;
    my $params;

    my $noarg_rx = '^\s*(\w+)\s*([;\{]|$)';
    my $arg_rx   = '(\w+):\s*(?:\(([^\)]+)\))?\s*(\w+)?(?:\s+|;)';

    # The objc message we will be sending
    my @message;

    # If there are no arguments (only matches method name)
    if($remainder =~ /$noarg_rx/){
        push(@methodName, $1);

    # If there are arguments, parse them
    }elsif($remainder =~ /$arg_rx/){
        (my(@remainder)) = ($remainder =~ /$arg_rx/g);

        # Fill our arrays from the remainder of the parsed method
        while(@remainder){
            push( @methodName,  shift @remainder );

            my $argType = shift @remainder;
            my $argName = shift @remainder;

            $argType = "id" unless $argType;

            unless ($argName){
                $argName = $argType;
                $argType = "id";
            }
            
            push( @type,        $argType );
            push( @name,        $argName );
        }

    # If we can't parse the method, complain
    }else{
        print("\nCouldn't parse method: ",$origmethod,);
        return;
    }

    my @params;
    # Build the params and message
    if(int(@methodName) == 1 && int(@name) == 0){
        push(@message, $methodName[0]);

    }else{
        for(my $i = 0; $i < int @methodName; $i++){
            push(@params, "$type[$i] p$i");
            push(@message, "$methodName[$i]:p$i");
        }
    }

    # What object will we be sending messages to?
    my ($receiver,$logLine,$methodName);

    # If the method is a class method
    if($isClassMethod){
        unshift(@params, "Class CLASS");
        $receiver = "CLASS";
        $logLine = "\tif (!CLASS) CLASS = NSClassFromString(\@\"$class\");\n";
        $class .= '_';

    # If the method is an instance method
    }else{
        unshift(@params, "$class* THIS");
	    $receiver = "THIS";
        $logLine = "";
    }

    # The fully-qualified C function name separated by _s (:s don't work)
    $methodName = join("_",  $class, @methodName);
    $logLine .= "\tNSLog(\@\"$methodName: \%\@\\n\", $receiver);";
    
    if(exists $methodHash->{$methodName}){
        print("\n\t\tDuplicate method name: $methodName");
        return ();
    }
    
    $methodHash->{$methodName} = "1";

    # The parameters to the C function
    $params     = join(", ", @params);

    # The objc message to send the object
    $message    = join(" ",  @message);

    # Will we be returning?
    my $retter = ($retType =~ /void/) ? "" : "return ";

    # return the method we will be using
    return ( "$retType $methodName ($params) {",
             $logLine,
             "\t${retter}[$receiver $message];",
             "}"
            );             
}

# Parse file
sub parseFile {
    my $filename = shift();

    my $getProtocols = shift();

    my %methods = ();
    my $addAlloc = 0;

    my $genDate = scalar localtime;

    my @out = ("/* Generated by genstubs.pl",
               " * (c) 2004 kangaroo, C.J. and Urs",
               " * Generation date: $genDate",
               " */",
               "",
               "",
              );
    my @protocolOut = ();

    (my($name, $path, $suffix)) = fileparse($filename, ".h");
    (my (undef, undef, undef, undef, $dirpart)) = split(/\//, $filename);
    $dirpart =~ s/\.framework//;

    my $skip = 0;
    my $isProtocol = 0;
    my $protocol;
    my $interface = $name;
    
    push(@out, "#import <$dirpart/$name.h>");
    push(@out, "#import <Foundation/NSString.h>");
    
    open(FILE, "<$filename") or die "Couldn't open $filename: $!";

    while(my $line = <FILE>) {
        chomp $line;
       
    	commentsBeGone(\$line, \*FILE);
    
        # Ignore #import lines
        next if($line =~ /#import/);

        # Determine the interface we are in
        if($line =~ /\@interface (\w+)(.*)/){
            $interface = $1;
            #$addAlloc = 1 if ($interface eq $name);

            if ($2 =~ /<(\w+)>/ && $getProtocols == 0){
                my $refProto = $1;
                my $i;
                    
                print(" $interface refers to $refProto ($#{ $protocols{$refProto} })");
                foreach $i ( 0 .. $#{ $protocols{$refProto} } ) {
                    push(@out, "", parseMethod($protocols{$refProto}[$i], $interface, \%methods));
                }
            }
        }else{
            if($line =~ /\@protocol (\w+)/){
                $protocol = $1;
                $isProtocol = 1;
            }else{
                if($line =~ /\@end/ && $isProtocol == 1){
                    $protocols{$protocol} = [ @protocolOut ] if ($getProtocols == 1);
                    $isProtocol = 0;
                }
            }
        }

    	my($class, $super);
    
    	# Capture class and superclass names
    	if($line =~ /^\s*\@interface\s+(\w+)(?:\s*:\s*(\w+))?\s*$/) {
    	    ($class, $super) = ($1, $2);
    	}
    
    	if($line =~ /^\s*\@end/){
    	    ($class, $super) = (undef, undef);
    	}
    
    	my %objC =
    	    ( class                => $class,
    	      super                => $super,
    	      "method name"        => undef,
    	      "method parts"       => [],
    	      "arg names"          => [],
    	      "arg types"          => [],
    	      "is instance method" => undef,
    	      receiver             => undef,
    	    );
    
    	my %c =
    	    ( "function name" => undef,
    	      "param types"   => [],
    	      "param names"   => [],
    	      "params"        => undef,
    	      "return type"   => undef,
    	    );
    
    	my %cSharp =
    	    ( class         => $class,
    	      super         => $super,
    	      "method name" => undef,
    	      "arg names"   => [],
    	      "arg types"   => [],
    	    );

        # If this is a class or instance method definition
        if($line =~ /^\s*[+-]/){
    	    # For lines that end in a definition,
    	    # Replace { ... } with a semicolon
    	    $line =~ s/\{[^\}]*\}\s*/;/;
    
    	    # If the line doesn't end with a semicolon, whitespace, end of line
    	    # Do the following until it does
    	    while($line !~ /;\s*$ /x){ # Stupid emacs.
        		$line =~ s://.*::;
        		# Append the next line
                $line .= <FILE>;
        		# Remove trailing newline
        		chomp $line;
        		# Get rid of comments
        		commentsBeGone(\$line, \*FILE);
        		# Replace { ... } with a semicolon
        		$line =~ s/\{[^\}]*\}/;/;
            }

            if($isProtocol == 1) {
                push(@protocolOut, $line);
            }else{
		        push(@out, "", parseMethod($line, $interface, \%methods, \%objC)) unless $getProtocols;
            }
        }
    }

    if($addAlloc && !($name =~ /NSProxy/ || $name =~ /NSObject/)){
        push(@out,
             "",
             "$name * ${name}__alloc(){",
             "\tNSLog(\@\"${name}__alloc()\\n\");",
             "\treturn [$name alloc];",
             "}"
            );
    }

    if ($getProtocols == 0) {
        my $numMethods = int(keys %methods);
        print " $numMethods methods.\n" if ($numMethods > 1);
        print " 1 method.\n" if ($numMethods == 1);
        print " no methods.\n" if ($numMethods < 1);
    }
    return @out;
}

sub parseDir {
    my $sourcedir = shift();
    my $destdir = shift();
    my $getProtocols = shift();

    opendir(my $dh, $sourcedir);

    my($name, $path, $suffix);
    print "Processing $sourcedir:\n" unless $getProtocols;

    foreach my $filename (readdir($dh)) {
        next if $filename =~ /^\./;
        next unless $filename =~ /\.h$/;

        ($name, $path, $suffix) = fileparse("$sourcedir/$filename", ".h");

        print "\t$filename" unless $getProtocols;

        my @file = parseFile("$path/$filename",$getProtocols);
        if ($getProtocols == 0) {
            my $stubfile = "src/$destdir/${name}_stub.m";
    
            open OUT, ">$stubfile" or die "Can't open $stubfile: $!";
            print OUT join($/, @file);
            close OUT;
        }
    }

    print "\n" if ($getProtocols == 0);
}

sub makeDirs {
    unless(-d "src"){
        mkdir "src" or die "Couldn't make dir 'src': $!";
    }
    unless(-d "src/appkit"){
        mkdir "src/appkit" or die "Couldn't make dir 'src/appkit': $!";
    }
    unless(-d "src/foundation"){
        mkdir "src/foundation" or die "Couldn't make dir 'src/foundation': $!";
    }
}

sub commentsBeGone()
{
    my $line = shift();
    my $FH = shift();

    # Rid ourselves of multi-line comments
    if( $$line =~ m:/\*: ){
	while( $$line !~ m:/\*.*\*/: ){
	    $$line .= <$FH>;
	    chomp $$line;
	}

	$^W = 0;
	$$line =~ s{
                     /\*         ##  Start of /* ... */ comment
                     [^*]*\*+    ##  Non-* followed by 1-or-more *'s
                     (
                       [^/*][^*]*\*+
                     )*          ##  0-or-more things which don't start with /
                                 ##    but do end with '*'
                     /           ##  End of /* ... */ comment

                   |         ##     OR  various things which aren't comments:

                     (
                       "           ##  Start of " ... " string
                       (
                         \\.           ##  Escaped char
                       |               ##    OR
                         [^"\\]        ##  Non "\
                       )*
                       "           ##  End of " ... " string

                     |         ##     OR

                       '           ##  Start of ' ... ' string
                       (
                         \\.           ##  Escaped char
                       |               ##    OR
                         [^'\\]        ##  Non '\
                       )*
                       '           ##  End of ' ... ' string

                     |         ##     OR

                       .           ##  Anything other char
                       [^/"'\\]*   ##  Chars which doesn't start a comment, string or escape
                     )
                   }{$2}gxs;
	$^W = 1;

	$$line =~ s://.*::;
    }
}
